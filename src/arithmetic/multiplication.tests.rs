use paste::paste;

mod multiply_at_product_index {
    use super::*;

    macro_rules! impl_case {
        ($name:ident: $idx:literal => $expected:expr) => {
            #[test]
            fn $name() {
                let (a, b) = test_input();
                let a = BigDigitSliceP19::from_slice(&a);
                let b = BigDigitSliceP19::from_slice(&b);
                let mut product = DigitVec::new();
                let expected: &[u64] = &$expected;
                multiply_at_product_index(
                    &mut product, a, b, $idx
                );
                assert_eq!(product.digits, expected);
            }
        };
    }

    mod random_values {
        use super::*;

        fn test_input() -> (Vec<u64>, Vec<u64>) {
            let a = vec![
                1745623865429447471,
                9152528756446785169,
                791242510259261833,
                8695454801466577396,
                8392994416015036890,
                2912771882945679798,
                8993891992610859856,
                8294679885144779824,
                8631634693823981953,
                366928013
            ];
            let b = vec![
                518171251856216712,
                8211715648977239115,
                1585852536764360977,
                1552672896608399639,
                1044291249247
            ];
            (a, b)
        }

        impl_case!(case_1: 1 => [
            3259170168870572493,
            8530725771486096200,
            2353601569174537990,
            9915907985447408257,
            5505012768436728039,
            3337388859546710366,
            1787670230149175286,
            7565280555772427422,
            7309104897441821141,
            4201853743352582046,
            9605931707432557799,
            9324155135517901886,
            3179713980940485874,
            38
        ]);

        impl_case!(case_3: 3 => [
            4519975091742652829,
            9915907985447408256,
            5505012768436728039,
            3337388859546710366,
            1787670230149175286,
            7565280555772427422,
            7309104897441821141,
            4201853743352582046,
            9605931707432557799,
            9324155135517901886,
            3179713980940485874,
            38
        ]);

        impl_case!(case_9: 9 => [
            8171925425020376989,
            4201853743352582045,
            9605931707432557799,
            9324155135517901886,
            3179713980940485874,
            38
        ]);

        impl_case!(case_12: 12 => [
            7983943745001026698,
            3179713980940485874,
            38
        ]);

        impl_case!(case_20: 20 => []);
    }
}

mod multiply_big_int_with_ctx {
    use super::*;

    macro_rules! impl_case {
        (full => $expected:literal) => {
            #[test]
            fn case_full() {
                let (x, y) = test_input();
                let product = &x * &y;
                let expected: BigInt = $expected.parse().unwrap();

                assert_eq!(&expected, &product);
            }
        };
        ($prec:literal => $expected:literal E $exp:literal) => {
            paste! {
                #[test]
                fn [< case_prec $prec >] () {
                    impl_case!(
                        IMPL;
                        ctx=Context::default().with_prec($prec);
                        $expected;
                        $exp
                    );
                }
            }
        };
        ($prec:literal; $mode:ident => $expected:literal E $exp:literal) => {
            paste! {
                #[test]
                fn [< case_prec $prec _ $mode:lower >]() {
                    impl_case!(
                        IMPL;
                        ctx=Context::default().with_rounding_mode(RoundingMode::$mode).with_prec($prec);
                        $expected;
                        $exp
                    );
                }
            }
        };
        ($prec:literal; $($modes:ident),+ => $expected:literal E $exp:literal) => {
            $( impl_case!($prec; $modes => $expected E $exp); )*
        };
        (IMPL; ctx=$ctx:expr; $expected:literal; $exp:literal) => {
            let (x, y) = test_input();
            let ctx = $ctx.unwrap();
            let product = multiply_big_int_with_ctx(&x, &y, ctx);

            let expected: BigInt = $expected.parse().unwrap();
            let scale = -$exp;

            assert_eq!(&expected, &product.value);
            assert_eq!(&scale, &product.scale);
        };
    }

    mod mulz_stuff {
        use super::*;

        fn test_input() -> (BigInt, BigInt) {
            let x: BigInt = "1155226260781990200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000".parse().unwrap();
            let y: BigInt = "7500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000".parse().unwrap();
            (x, y)
        }

        impl_case!(20                       => "86641969558649265000" E 290);
        impl_case!(18; HalfUp               => "866419695586492650" E 292);
        impl_case!(16; Up, HalfUp, HalfEven => "8664196955864927" E 294);
        impl_case!(16; Down, HalfDown       => "8664196955864926" E 294);
        impl_case!(15; Up, HalfDown         => "866419695586493" E 295);
        impl_case!(15; Down                 => "866419695586492" E 295);
        impl_case!( 3; HalfUp               => "866" E 307);
    }

    mod mul_stuff {
        use super::*;

        fn test_input() -> (BigInt, BigInt) {
            let x: BigInt = "230134622236549555995211986626222699902919552403311068655782487235360869740373750138395520899795192776856789295000000".parse().unwrap();
            let y: BigInt = "14293213600958985303333846898378944669728091790434135672846064625014252175269303162751477769546102012233954333273726511104485055758813349716438744379331517132722718015116165694607959258435272025702738339275667597501313358033107443840555382841970678973851997248262639615206455939322314712306500000000000000000000000000000000".parse().unwrap();
            (x, y)
        }

        impl_case!(20 => "32893633126030082513" E 419);
        impl_case!(401 => "32893633126030082513378632456028104243338158146601751534822570641115861940893690474203736021657204584394456560452273117013862292944834269220913901434456366640765512794407601501204644375698772310462659595240672712968083946415944676232524453019368460583076233422452053267394081654933088569072574309446551869537537085955808336137944176420693881753901339121561334586231165213326029020686758979692139589175" E 38);
        impl_case!(400; HalfUp => "3289363312603008251337863245602810424333815814660175153482257064111586194089369047420373602165720458439445656045227311701386229294483426922091390143445636664076551279440760150120464437569877231046265959524067271296808394641594467623252445301936846058307623342245205326739408165493308856907257430944655186953753708595580833613794417642069388175390133912156133458623116521332602902068675897969213958918" E 39);
        impl_case!(400; HalfDown => "3289363312603008251337863245602810424333815814660175153482257064111586194089369047420373602165720458439445656045227311701386229294483426922091390143445636664076551279440760150120464437569877231046265959524067271296808394641594467623252445301936846058307623342245205326739408165493308856907257430944655186953753708595580833613794417642069388175390133912156133458623116521332602902068675897969213958917" E 39);

    }

    // test (2^5000-1) * (2^1500-1)
    mod mul_2p5000m1_2p1501m1 {
        use super::*;

        fn test_input() -> (BigInt, BigInt) {
            let x: BigInt = "141246703213942603683520966701614733366889617518454111681368808585711816984270751255808912631671152637335603208431366082764203838069979338335971185726639923431051777851865399011877999645131707069373498212631323752553111215372844035950900535954860733418453405575566736801565587405464699640499050849699472357900905617571376618228216434213181520991556677126498651782204174061830939239176861341383294018240225838692725596147005144243281075275629495339093813198966735633606329691023842454125835888656873133981287240980008838073668221804264432910894030789020219440578198488267339768238872279902157420307247570510423845868872596735891805818727796435753018518086641356012851302546726823009250218328018251907340245449863183265637987862198511046362985461949587281119139907228004385942880953958816554567625296086916885774828934449941362416588675326940332561103664556982622206834474219811081872404929503481991376740379825998791411879802717583885498575115299471743469241117070230398103378615232793710290992656444842895511830355733152020804157920090041811951880456705515468349446182731742327685989277607620709525878318766488368348965015474997864119765441433356928012344111765735336393557879214937004347568208665958717764059293592887514292843557047089164876483116615691886203812997555690171892169733755224469032475078797830901321579940127337210694377283439922280274060798234786740434893458120198341101033812506720046609891160700284002100980452964039788704335302619337597862052192280371481132164147186514169090917191909375".parse().unwrap();
            let y: BigInt = "35074662110434038747627587960280857993524015880330828824075798024790963850563322203657080886584969261653150406795437517399294548941469959754171038918004700847889956485329097264486802711583462946536682184340138629451355458264946342525383619389314960644665052551751442335509249173361130355796109709885580674313954210217657847432626760733004753275317192133674703563372783297041993227052663333668509952000175053355529058880434182538386715523683713208549375".parse().unwrap();
            (x, y)
        }

        impl_case!(100 => "4954180389441794407302644533158844937036173071799942385207702899881096950794929284226174201155309760" E 1857);
        impl_case!(70  => "4954180389441794407302644533158844937036173071799942385207702899881097" E 1887);
        impl_case!(20  => "49541803894417944073" E 1937);
    }

    mod multiply_313313e185_140912e85 {
        use super::*;

        fn test_input() -> (BigInt, BigInt) {
            let x: BigInt = "31331330514777647459696918012218766637269396231379435058341584170846149718531941093035596483272466942484919002494751588025494203950111183556196762802239021663296916615390846043521157975900649".parse().unwrap();
            let y: BigInt = "1409125393389843319552855599302577071349036214812589000980540875883362915766473073232671889".parse().unwrap();
            (x, y)
        }

        impl_case!(full => "44149773437063254678149469396251230458443452710019771114377331920312228495036605502543146558201981056772851870606187717471634519393139631393769297684773531284154562671396651882745113413784696354015721073630190690162770887707923095632780007819514677121000367593109419444597479155961");
        impl_case!(100  => "4414977343706325467814946939625123045844345271001977111437733192031222849503660550254314655820198106" E 181);
        impl_case!(50  => "44149773437063254678149469396251230458443452710020" E 231);
        impl_case!(21  => "441497734370632546781" E 260);
    }
}


mod test_multiply_quad_spread_into {
    use super::*;

    macro_rules! impl_case {
        ( wrapping: $($toks:tt)* ) => {
            impl_case!(multiply_quad_spread_into_wrapping; $($toks)*);
        };
        (
            $func:ident;
            $s:literal @ $n:literal,
            [ $a:literal, $b:literal, $y:literal, $z:literal] => $expected:expr
        ) => {
            paste!{
                #[test]
                fn [< case_ $n _ $a _ $b _ $y _ $z >]() {
                    let mut result = vec![0; $s];
                    $func(&mut result, $n, $a, $b, $y, $z);
                    let expected = &$expected;
                    assert_eq!(expected, result.as_slice());
                }
            }
        };
        ( $($toks:tt)* ) => {
            impl_case!(multiply_quad_spread_into; $($toks)*);
        };
    }

    impl_case!(
        8 @ 2,
        [2559712337, 684026673, 1163340730, 1823138616]
         => [0u32, 0, 3001179060, 4203670869, 1059648540, 580714756, 0, 0]);

    impl_case!(
        6 @ 1,
        [4294967295, 4294967295, 4294967295, 4294967295]
         => [0u32, 2, 0, 4294967292, 4294967295, 1]);

    impl_case!(
        wrapping: 8 @ 6,
        [2559712337, 684026673, 1163340730, 1823138616]
         => [1059648540u32, 580714756, 0, 0, 0, 0, 3001179060, 4203670869]);
}


#[cfg(proptests)]
mod props {
    use super::*;
    use proptest::*;
    use proptest::num::f64::*;
    use num_traits::FromPrimitive;

    fn random_f64() -> Any {
        NORMAL | SUBNORMAL | ZERO | NEGATIVE
    }

    proptest! {
        #[test]
        fn test_multiply_decimals_with_context(a in random_f64(), b in random_f64(), prec in 1..6000u64) {
            let prec = NonZeroU64::new(prec).unwrap();
            let a: BigDecimal = BigDecimal::from_f64(a).unwrap();
            let b: BigDecimal = BigDecimal::from_f64(b).unwrap();

            let a_times_b = &a * &b;

            let mode = RoundingMode::HalfDown;
            let a_times_b_down = a_times_b.with_precision_round(prec, mode);

            let mut dest = BigDecimal::default();
            let ctx = Context::new(prec, mode);
            super::multiply_decimals_with_context(&mut dest, &a, &b, &ctx);

            prop_assert_eq!(a_times_b_down, dest)
        }
    }
}
